<html>
<head>
  <title>第九章 排序</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/6.1.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="692"/>
<h1>第九章 排序</h1>

<div>
<span><div><div>第九章  排序</div><div><br/></div><div>1.排序的稳定性：假设ki=kj，且在排序前的序列中ri领先于rj。如果排序后ri任然领先于rj，则是稳定的，否则是不稳定</div><div><br/></div><div>2.内排序与外排序：内排序是在整个过程中，待排序的所有记录全部被放置在内存中。 外排序由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。</div><div><br/></div><div>对内排序来说，性能受到三方面影响：</div><div>（1）.时间性能：比较和移动</div><div>（2）辅助空间</div><div>（3）算法的复杂性</div><div><br/></div><div>内排序：插入排序，交换排序，选择排序，归并排序</div><div><br/></div><div>4.冒泡排序</div><div>改进的</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void BubbleSort(SqList* L)</div><div>{</div><div>    int i,j;</div><div>    Status flag=true;</div><div>    for(i=1;i&lt;=L-&gt;Length &amp;&amp; flag ;i++)</div><div>    {</div><div>        flag=false;</div><div>        for(j=L-&gt;Length-1;j&gt;=i;j--)</div><div>        {</div><div>            if(L-&gt;r[j]&gt;L-&gt;r[j+1])</div><div>            {</div><div>                swap(L,j,j+1);</div><div>                flag=true;</div><div>            }</div><div>        }</div><div>    }</div><div>}</div></div><div><br/></div><div>5.简单选择排序：时间复杂度为O（n^2）,性能上略优于冒泡排序</div><div><img src="第九章 排序_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>6.直接插入排序</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void InsertSort(SqList* L)</div><div>{</div><div>    int i,j;</div><div>    for(i=2;i&lt;=L-&gt;Length;i++)</div><div>    {</div><div>        if(L-&gt;r[i]&lt;L-&gt;r[i-1])</div><div>        {</div><div>            L-&gt;r[0]=L-&gt;r[i]</div><div>            for(j=i-1;L-&gt;r[j]&lt;L-&gt;r[0];j--)</div><div>            {</div><div>                L-&gt;r[j+1]=L-&gt;r[j];</div><div>            }</div><div>            L-&gt;r[j+1]=L-&gt;r[0];</div><div>        }</div><div>    }</div><div>}</div></div><div>时间复杂度为O（n^2）,性能上略优于冒泡排序和简单选择排序</div><div><br/></div><div>7.希尔排序（对直接插入排序的改进）</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void ShellSort(SqList* L)</div><div>{</div><div>    int i,j;</div><div>    int increment=L-&gt;Length;</div><div>    do</div><div>    {</div><div>        increment=increment/3+1;</div><div>        for(i=increment+1;i&lt;=L-&gt;Length;i++)</div><div>        {</div><div>            if(L-&gt;r[i]&lt;L-&gt;r[i-incremrnt])</div><div>            {</div><div>                L-&gt;r[0]=L-&gt;r[i];</div><div>                for(j=i-increment;j&gt;0 &amp;&amp;L-&gt;r[0]&lt;L-&gt;r[j];j=j-increment)</div><div>                    L-&gt;r[j+increment]=L-&gt;r[j];</div><div>                L-&gt;r[j+incrememt]=L-&gt;r[0];</div><div>            }</div><div>        }</div><div>    }while(increment&gt;1)</div><div>}</div></div><div>时间复杂度为O（n^1.5），由于记录是跳跃式的，不是稳定的排序</div><div><br/></div><div>8.堆排序（对简单选择排序的改进）</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void HeapSort(SqList* L)</div><div>{</div><div>    int i;</div><div>    for(i=L-&gt;Length/2;i&gt;0;i--)</div><div>        HeapAdjust(L,i,L-&gt;Length);</div><div>    for(i=L-&gt;length;i&gt;1;i++)</div><div>        {</div><div>            swap(L,1,i);</div><div>            HeapAdjust(A,i,L-&gt;Length-1);</div><div>        }</div><div>}</div><div><br/></div><div>void HeadAdjust(SqList* L,int s,int m)</div><div>{</div><div>    int temp,j;</div><div>    temp=L-&gt;r[s];</div><div>    for(j=2*s;j&lt;=m;j*=2)</div><div>    {</div><div>        if(j&lt;m &amp;&amp; L-&gt;r[j]&lt;L-&gt;r[j+1])</div><div>            ++j;</div><div>        if(temp&gt;=L-&gt;r[j])</div><div>            break;</div><div>        L-&gt;r[s]=L-&gt;r[j];</div><div>        s=j;</div><div>    }</div><div>    L-&gt;r[s]=temp;</div><div>}</div></div><div>时间复杂度为O（nlogn）,也是不稳定的排序</div><div><br/></div><div>9.归并排序</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void MSort(int SR[],int TR[],int s,int t)</div><div>{</div><div>    int m;</div><div>    int TR2[MAXSIZE+1];</div><div>    if(s==t)</div><div>        TR[s]=SR[s];</div><div>    else</div><div>    {</div><div>        m=(s+t)/2;</div><div>        MSort(SR,TR2,s,m);</div><div>        <span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">MSort(SR,TR2,m+1,t);</span></div><div><font face="Monaco">               Merge(TR2,TR1,s,,m,t);</font></div><div>    }</div><div>}</div><div><br/></div><div>void Merge(int SR[],int TR[],int i,int m,int n)</div><div>{</div><div>    int j,k,l;</div><div>    for(j=m+1,k=i;i&lt;=m &amp;&amp; j&lt;=n;k++)</div><div>    {</div><div>        if(SR[i]&lt;SR[j])</div><div>            TR[k++]=SR[i++];</div><div>        else</div><div>            <span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">TR[k++]=SR[j++];</span>           </div><div>    }</div><div>    if(i&lt;=m)</div><div>    {</div><div>        for(l=0;l&lt;=m-i;l++)</div><div>            TR[k+1]=SR[i+1];</div><div>    }</div><div>   if (j&lt;=n)</div><div>    {</div><div>        for(l=0;l&lt;=n-j;l++)</div><div>            TR[k+1]=SR[j+1];</div><div>    }</div><div>}</div></div><div>时间复杂度为O（nlogn）,有SR[i]&lt;SR[j]，两两比较，是稳定的排序</div><div><br/></div><div>10.快速排序</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void QuickSort(SqList* L)</div><div>{</div><div>    QSort(L,1,L-&gt;Length);</div><div>}</div><div>QSort(SqList* L,int low,int high)</div><div>{</div><div>    int pivot;</div><div>    if(low&lt;high)</div><div>    {</div><div>        pivot=Partition(L,low,high);</div><div>        QSort(L,low,pivot-1);</div><div>        <span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">QSort(L,pivot+1,high);</span></div><div>    }</div><div>}</div><div>int <span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Partition(Sqlist* L,int low ,int high)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">     int key=L-&gt;r[low];</span></div><div>   while(low&lt;high)</div><div>    {</div><div>        while(low&lt;high &amp;&amp; L-&gt;r[high]&gt;=key)</div><div>            high--;</div><div>        swap(L,low,high);    </div><div>        while(low&lt;high &amp;&amp;L-&gt;r[low]&lt;=key)</div><div>            low++;</div><div>        <span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">swap(L,low,high);  </span></div><div>    }</div><div>  return low;</div><div>}</div></div><div>时间复杂度为O（nlogn）,不稳定</div><div><br/></div><ol start="11"><li><div><img src="第九章 排序_files/Image [1].png" type="image/png" data-filename="Image.png"/></div></li></ol><div><br/></div><div><img src="第九章 排序_files/Image [2].png" type="image/png" data-filename="Image.png" width="644"/></div><div><br/></div></div><div><br/></div></span>
</div></body></html> 