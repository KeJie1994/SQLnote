<html>
<head>
  <title>条款21： 必须返回对象时，别妄想返回其reference</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/6.1.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="478"/>
<h1>条款21： 必须返回对象时，别妄想返回其reference</h1>

<div>
<span><div>条款21： 必须返回对象时，别妄想返回其reference</div><div><br/></div><div><span style="color: rgb(79, 79, 79); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">在掌握了pass by reference后，刚开始一心一意想把所有pass by value替换为pass by reference。这时往往会犯下一个错误：传递一些reference指向不存在的对象。考虑一个用以表现有理数乘积的class。</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Rational</div><div>{</div><div>public:</div><div><span>    Rational(int numerator=0,int denomination=1);</span><br/></div><div><span>private:</span></div><div><span><span>    int n,d;</span><br/></span></div><div><span>    friend Rational operator*(const Rational&amp; lhs,const Rational&amp; rhs);</span><br/></div><div>}</div></div><div>这个版本的operator* 代价是一个对象的创建+析构+另一个对象的创建（创建一个新对象保存结果，之后用这个新对象返回，返回时初始化另一个对象，再析构新对象）</div><div><br/></div><div>但是如果用reference方式传递就不会有任何代价，但是reference只是个名称，代表一个已经存在的对象，任何时候看到reference都要问自己它的另一个名称是什么？ 如果上述operator* 返回的是一个reference，那么他一定指向一个已经存在的Rational</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Rational a{1,2);</div><div>Rational b(3,5);</div><div>Rational c=a*b;</div></div><div><br/></div><div>期望原来就存在一个值为3/10的Ration对象根本不实际，如果operator* 要返回一个reference指向此数值，它必须自己创建那个Rational</div><div><span style="color: rgb(79, 79, 79); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">函数创建新对象有两种途径，在stack上或在heap上创建。如果定义local变量，那么就在stack上创建</span></div><div><span style="color: rgb(79, 79, 79); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>const Rational&amp; operator*(const Rational&amp; lhs,const Rational&amp; rhs)</div><div>{</div><div><span>    Rational result(lhs.n*rhs.n,lhs.d*rhs.d);</span><br/></div><div><span>    return result;</span><br/></div><div>}</div></div><div>reference执行result，然而result是local对象，返回时被销毁了。</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const Rational&amp; operator*(const Rational&amp; lhs,const Rational&amp; rhs)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    Rational* result=new Rational(lhs.n*rhs.n,lhs.d*rhs.d);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    return result;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div></div><div>这里不仅要付出一个构造函数的代价，还面临一个问题：谁负责将new出来的对象delete？会造成内存泄漏</div><div><br/></div><div><span style="color: rgb(79, 79, 79); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">在上面的两种做法中（在stack和在heap上创建对象），都因为operator*返回结果调用构造函数而受到惩罚。我们最初的目标是避免如此的构造函数的调用。还有一个办法避免任何构造函数的调用：让operator*返回一个指向在函数内部定义的static Rational对象：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const Rational&amp; operator*(const Rational&amp; lhs,const Rational&amp; rhs)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    static Rational result;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>    result=...'</span><br/></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>   return result;</span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">bool operator==(const Rational&amp; lhs,const Rational&amp; rhs);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Rational a,b,c,d;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">if((a*b)==(c*d))</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>    doSomething();</span><br/></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>else</span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span><span>    doOtherthing();</span><br/></span></span></div></div><div><span style="color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">上述表达式(a*b)==(c*d)总是返回true。因为operator*返回的对象都是指向operator*内部定义的static对象。这个对象只有一个，当计算后者时，前者被覆盖。因此永远是两个相同的Rational对象的作比较</span></div><div><span style="color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">(1)绝对不要反悔pointer或reference指向一个local stack对象，指向一个heap-allocated对象也不是一个好方法，更不能指向一个local static对象。该让编译器复制对象的时候，就让它去复制</span></div></span>
</div></body></html> 