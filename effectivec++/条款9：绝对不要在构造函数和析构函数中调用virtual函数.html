<html>
<head>
  <title>条款9：绝对不要在构造函数和析构函数中调用virtual函数</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/6.1.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="466"/>
<h1>条款9：绝对不要在构造函数和析构函数中调用virtual函数</h1>

<div>
<span><div><span style="font-size: 14pt;">条款9：绝对不要在构造函数和析构函数中调用virtual函数</span></div><div><br/></div><div>    （1）在构造函数和析构函数期间不要调用virtual函数，因为这个类不用下降至派生类</div><div><br/></div><div><span style="font-size: 14pt;">条款10：令operator=返回一个reference to *this</span></div><div><br/></div><div><span style="font-size: 14pt;">条款11：在operator=实现自我赋值</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//例如使用一个class管理一个指针</div><div>class Widght</div><div>{</div><div>public：</div><div>    Widght&amp; operator=(const Widght&amp; rhs)</div><div>    {</div><div>        delete p;</div><div>        p=new int(rhs.p)</div><div>        return *this;</div><div>    }</div><div>    int *p;</div><div>}// <span style="color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">如果上面代码自我赋值，在使用指针p之前已经将其释放掉了</span></div><div><br/></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51);"><font style="font-size: 9pt;">class Widght</font></span></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51);"><font style="font-size: 9pt;">{</font></span></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51);"><font style="font-size: 9pt;">public：</font></span></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51);"><font style="font-size: 9pt;">    Widght&amp; operator=(const Widght&amp; rhs)</font></span></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51);"><font style="font-size: 9pt;">    {</font></span></div><div>    if(this==&amp;rhs)    //证同测试</div><div>        return *this;</div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51);"><font style="font-size: 9pt;">        delete p;</font></span></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51);"><font style="font-size: 9pt;">        p=new int(rhs.p)</font></span></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51);"><font style="font-size: 9pt;">        return *this;</font></span></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51);"><font style="font-size: 9pt;">    }</font></span></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51);"><font style="font-size: 9pt;">    int *p;</font></span></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51);"><font style="font-size: 9pt;">}//这个方法能解决自我赋值的问题，单数如果p=new int（rhs.p）失败，此时widght对象会持有一个指针，这个指针指向了被释放的内存</font></span></div><div><br/></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51);"><font style="font-size: 9pt;">//解决方法：</font></span></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51);"><font style="font-size: 9pt;">// <span style="color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">copy and swap技术</span></font></span></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51);"><font style="font-size: 9pt;"><span style="color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">//引用传递</span></font></span></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51);"><font style="font-size: 9pt;">class Widght</font></span></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51);"><font style="font-size: 9pt;">{</font></span></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51);"><font style="font-size: 9pt;">public：</font></span></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51);"><font style="font-size: 9pt;">    void swap(const Widght&amp; rhs);</font></span></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51);"><font style="font-size: 9pt;">    Widght&amp; operator=(const Widght&amp; rhs)</font></span></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51);"><font style="font-size: 9pt;">    {</font></span></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51);"><font style="font-size: 9pt;">       Widght tmp(ths);   //复制一份数据</font></span></div><div>    swap(tmp);</div><div>    return *this;  <span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51); font-size: 9pt;">//零时变量会自动销毁</span></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51);"><font style="font-size: 9pt;">    }</font></span></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51);"><font style="font-size: 9pt;">    int *p;    </font></span></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51);"><font style="font-size: 9pt;">}</font></span></div><div><br/></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51);"><font style="font-size: 9pt;">//值传递</font></span></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51); font-size: 9pt;">class Widght</span></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51); font-size: 9pt;">{</span></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51); font-size: 9pt;">public：</span></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51); font-size: 9pt;">    </span><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51); font-size: 9pt;">void swap(const Widght&amp; rhs);</span></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51); font-size: 9pt;">    Widght&amp; operator=(const Widght rhs)</span></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51); font-size: 9pt;">    {</span></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51); font-size: 9pt;">       swap(rhs)</span></div><div>    return *this;</div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51); font-size: 9pt;">    }</span></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51); font-size: 9pt;">    int *p;</span><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51); font-size: 9pt;">   </span></div><div><span style="font-family: &quot;PingFang SC&quot;; color: rgb(51, 51, 51); font-size: 9pt;">}</span></div></div><div>    （1）确保当前对象自我赋值是具有良好行为。其中技术包括比较“来源对象”和“目标对象”的对象,精心周到的语句顺序，以及copy-and-swap；</div><div>    （2）确定任何函数操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍正确</div><div><br/></div><div><font style="font-size: 14pt;">条款12：复制对象勿忘其每一个成分</font></div><div><font style="font-size: 14pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class SmapleClass</div><div>{</div><div>private:</div><div><span>    int a;</span><br/></div><div><span><span>    int b;</span><br/></span></div><div><span>public:</span></div><div><span>    SampleClass(const SampleClass&amp; s):a(s.a),b(s.b){}</span><br/></div><div>}</div><div><br/></div><div>//继承时不要忘记其基类部分</div><div>class Derived:public SampleClass</div><div>{</div><div>private:</div><div><span>    int derivedVal;</span><br/></div><div><span>public:</span></div><div><span><span>    Derived(const Derived&amp; d):SampleClass(d),derivedVal(d.derivedval){}</span><br/></span></div><div><span><span>    Derived&amp; operator=(const Derived&amp; d)</span><br/></span></div><div><span><span>    {</span><br/></span></div><div><span><span>    </span><span>    SampleClass::operator=(d);</span><br/></span></div><div><span>    </span><span>    derivedVal=d.derivedVal;</span><br/></div><div><span>    </span><span>    return *this;</span><br/></div><div><span><span>    }</span><br/></span></div><div>}</div></div><div>（copy构造函数和copy assignment操作符，称为copying函数）</div><div>(1)copying函数应该确保赋值“对象内的所有成员变量”和“所有base class成分”；</div><div>(2)不要尝试以某个copying函数实现另一个copying函数，应该讲共同技能放在第三个函数中</div><div><br/></div><div><br/></div></span>
</div></body></html> 