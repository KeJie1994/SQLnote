<html>
<head>
  <title>第三章 装饰模式</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/6.1.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1446"/>
<h1>第三章 装饰模式</h1>

<div>
<span><div><div>第三章 装饰模式</div><div><br/></div><div>1.第五个设计原则：类应该对扩展开放，对修改封闭</div><div><br/></div><div>2.在星巴克咖啡馆这个例子中，假如都是继承Beverage这个超类，多一项咖啡+调料组合就会多一个类，造成类爆炸。</div><div>   采用装饰器(调料)一层层包含被装饰的咖啡，最后调用最外层的装饰着的cost()就可以委托计算其内部计算价钱。</div><div>从Beverage类入手，这是一个基类，代表逻辑上的抽象(不一定是抽象类，看是否有抽象方法决定),被装饰着和装饰者都使用该基类，这基类中定义了装饰者和被装饰者的方法，其中抽象方法是装饰者和被装饰者同时需要的方法，而普通方法是装饰者则是装饰者覆盖使用的方法</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public abstract class Beverage</div><div>{</div><div>    string decscription=&quot;Unknown Beverage“”;</div><div>    public String getDescription()</div><div>    {</div><div>        return description;</div><div>    }</div><div>    public abstact double cost();</div><div>}</div><div>//将调料视为装饰器，这个装饰器为了能将被装饰部分包起来，继承自这个超类</div><div>public abstract class CondimentDecorator extends Beverage</div><div>{</div><div>    public abstract String getDescription();</div><div>}</div><div><br/></div><div>//构造一些饮品(被装饰者)</div><div>public class Espresso extends Beverage</div><div>{</div><div>    public Espresso</div><div>    {</div><div>        description=&quot;Espresso&quot;;</div><div>    }</div><div>    public double cost()</div><div>    {</div><div>        return 1.99;</div><div>    }</div><div>}</div><div>public class HouseBlend extend Beverage</div><div>{</div><div>    <span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public Espresso</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">        {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">            description=&quot;House Blend Coffee&quot;;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">        }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">        public double cost()</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">        {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">            return 0.89;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">        }</span></div><div>}</div><div><br/></div><div>//构建具体的装饰者，代表摩卡的Mocha</div><div>public class Mocha extends CondimentDecorator</div><div>{</div><div>    Beverage beverage;</div><div>    public Mocha(Beverage beverage)</div><div>    {</div><div>        this.beverage=beverage;</div><div>    }</div><div>    public String getDescription()</div><div>    {</div><div>        return beverage.getDescription()+&quot;,Mocha&quot;;</div><div>    }</div><div>    public double cost()</div><div>    {</div><div>        return 0.2+beverage.cost();</div><div>    }</div><div>}</div><div><br/></div><div>public class starbuzzCoffee</div><div>{</div><div>    publuc static void main()</div><div>    {</div><div>        Beverage beverage=new Beverage();</div><div>        System.out.println(beverage.getDescription()+&quot;$&quot;+beverage.cost();</div><div>        </div><div>        Beverage beverage3=new HouseBlend();</div><div>        beverage3=new Soy(beverage3);</div><div>        <span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">beverage3=new Mocha(beverage3);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">               beverage3=new whip(beverage3);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                <span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">System.out.println(beverage3.getDescription()+&quot;$&quot;+beverage3.cost();</span></span></div><div>    }</div><div>}</div></div><div><br/></div><div><br/></div><div>3.<span style="text-indent: 0pt; font-size: 13.92px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0); font-family: Arial; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 26px;">总结一下装饰模式特点：</span></div><ul style="margin: 0px 0px 0px 30pt; padding: 0px; font-size: 13.92px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); list-style-type: disc;"><li style="margin: 0px; padding: 0px; list-style: disc; background-image: none; background-repeat: repeat; background-position: 0% 0%;"><div><span style="color: rgb(0, 0, 0); font-family: Arial; font-size: 13.92px; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">装饰者和被装饰对象有相同的基类</span><span style="color: rgb(0, 0, 0); font-family: Arial; font-size: 13.92px; font-variant-caps: normal; font-variant-ligatures: normal;">--都是来自Beverage这个类。</span></div></li><li style="margin: 0px; padding: 0px; list-style: disc; background-image: none; background-repeat: repeat; background-position: 0% 0%;"><div><span style="color: rgb(0, 0, 0); font-family: Arial; font-size: 13.92px; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">继承关系：基类-&gt;被装饰者（就是具体的一些基类延伸），基类-&gt;装饰器-&gt;装饰者（传入基类）-</span><span style="color: rgb(0, 0, 0); font-family: Arial; font-size: 13.92px; font-variant-caps: normal; font-variant-ligatures: normal;">对应上面的代码。</span></div></li><li style="margin: 0px; padding: 0px; list-style: disc; background-image: none; background-repeat: repeat; background-position: 0% 0%;"><div><span style="color: rgb(0, 0, 0); font-family: Arial; font-size: 13.92px; font-variant-caps: normal; font-variant-ligatures: normal;">你可以用一个或多个装饰者包装一个对象--看看beverage3这个对象就知道了。</span></div></li><li style="margin: 0px; padding: 0px; list-style: disc; background-image: none; background-repeat: repeat; background-position: 0% 0%;"><div><span style="color: rgb(0, 0, 0); font-family: Arial; font-size: 13.92px; font-variant-caps: normal; font-variant-ligatures: normal;">在任何需要被包装者的场合可以用装饰过的对象代替它--比如首先我们在咖啡上加豆浆，然后我们在加豆浆的咖啡上想再加摩卡的话，我们可以直接在这个加过豆浆的咖啡对象上加摩卡。</span></div></li><li style="margin: 0px; padding: 0px; list-style: disc; background-image: none; background-repeat: repeat; background-position: 0% 0%;"><div><span style="color: rgb(0, 0, 0); font-family: Arial; font-size: 13.92px; font-variant-caps: normal; font-variant-ligatures: normal;">装饰者可以在所委托的被装饰者的行为上加上自己的行为，达到特定目的--getDescription和cost方法充分证明了这一点。</span></div></li></ul></div><div><br/></div></span>
</div></body></html> 