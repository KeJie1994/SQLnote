<html>
<head>
  <title>条款26：限制某个类所能产生的对象数量</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/6.1.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1590"/>
<h1>条款26：限制某个类所能产生的对象数量</h1>

<div>
<span><div><div>条款26：限制某个类所能产生的对象数量</div><div><br/></div><div>1</div><div>例如：只有一台打印机</div><div>该类的构造函数声明在类的 private，我们应把打印机对象封装在一个函数内，以便让每个人都能访问打印机，但是只有一个打印机对象被建立。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class PrintJob;                           </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                                           </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class Printer {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  void submitJob(const PrintJob&amp; job);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  void reset();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  void performSelfTest();  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">...  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">friend Printer&amp; thePrinter();  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">private:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  Printer();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  Printer(const Printer&amp; rhs);  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Printer&amp; thePrinter()</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  static Printer p;                          // 单个打印机对象</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  return p;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><br/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">thePrinter().reset();</span></div></div><div>三个部分组成：（1）构造函数为private，能组织建立对象。（2）全局函数thePrinter被声明为类的友元，让thePrinter避免私有构造函数引起的限制。（3）thePrinter包含一个静态Printer对象，这意味着只有一个对象被建立。</div><div><br/></div><div>thePrinter同样可以使用静态变量</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Printer</div><div>{</div><div>    public:</div><div>    ...</div><div>    static Printer&amp; thePrinter();</div><div>}</div><div><br/></div><div>//用户可能会频繁使用printer</div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Printer::thePrinter().reset();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Printer::thePrinter().submitJob(buffer);</span></div></div><div><br/></div><div>或者将 thePrinter 移出全局域，放入 namespace（命名空间）。把 Printer 类和thePrinter 函数放入一个命名空间，我们就不用担心别人也会使用 Printer 和 thePrinter名字；命名空间能够防止命名冲突。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>namespace PrintingStuff</div><div>{</div><div>    class Printer</div><div>    {</div><div>        </div><div>    }</div><div>}</div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">PrintingStuff::thePrinter().reset();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">PrintingStuff::thePrinter().submitJob(buffer);</span></div></div><div>两个地方需要注意：（1）唯一的 Pritner 对象是位于函数里的静态成员而不是在类中的静态成员在类中的静态对象实际上总是被构造（和释放），即使不使用该对象。与此相反，只有第一次执行函数时，才会建立函数中的静态对象，所以如果没有调用函数，就不会建立对象。（不过你得为此付出代价，每次调用函数时都得检查是否需要建立对象。）把Printer声明为类中的静态成员还有一个缺点，它的初始化时间不确定</div><div>（2）内联与函数内静态对象的关系</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">hePrinter 的非成员函数</span><span style="font-family: Monaco; font-size: 9pt;">形式</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Printer&amp; thePrinter()</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  static Printer p;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  return p;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div></div><div>如果用内联，意味着编译器同函数体替代该对函数的每一个调用。非成员函数还意味着内部链接（带有内部链接的函数可能在程序内被复制），就是说如果建立一个包含局部静态对象的非成员函数，你可能会使程序的静态对象的拷贝超过一个。</div><div><br/></div><div><br/></div><div>还有一种方法，计数对象的个数</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class Printer {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  class TooManyObjects{};                   // 当需要的对象过多时<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">就使用这个异常类   </span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  Printer();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ~Printer();  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">private:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  static size_t numObjects;  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  Printer(const Printer&amp; rhs); // 这里只能有一个 printer，<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">所以不允许拷贝</span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><br/></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">size_t Printer::numObjects = 0;  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Printer::Printer()</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  if (numObjects &gt;= 1) {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    throw TooManyObjects();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  }  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  继续运行正常的构造函数;  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ++numObjects;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Printer::~Printer()</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  进行正常的析构函数处理;  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  --numObjects;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div></div><div>这就可以限制建立对象的个数不为1</div><div><br/></div><ul><li><div>建立环境</div></li></ul><div><span>    假设彩色打印机继承于普通打印机</span><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Printer p;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">ColorPrinter cp;</span></div></div><div>会产生2个printer对象，抛出TooManyObjects异常</div><div><br/></div><div>当其他对象包含printer对象也会出错</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class CPFMachine {                           // 一种机器，可以复印，打印<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">发传真。</span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">private:     </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  Printer p;                                 // 有打印能力</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  FaxMachine f;                              // 有传真能力</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  CopyMachine c;                             // 有复印能力</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><br/></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">CPFMachine m1;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">CPFMachine m2;   //抛出<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">TooManyObjects异常</span></span></div></div><div><br/></div><div>利用计数的方法会出现问题，利用只声明的私有构造函数private（无friend），能产生了一种阻止派生类的通用方法。</div><div><br/></div><div>假设设计一个类，禁止派生出新类（存在非虚析构函数），可以建立任意数量的对象</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class FSA {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  // 伪构造函数</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  static FSA * makeFSA();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  static FSA * makeFSA(const FSA&amp; rhs);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">private:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  FSA();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  FSA(const FSA&amp; rhs);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">FSA * FSA::makeFSA()</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{ return new FSA(); }  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">FSA * FSA::makeFSA(const FSA&amp; rhs)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{ return new FSA(rhs); }  </span></div></div><div>不像thePrinter 函数总是返回一个对象的引用（引用的对象是固定的），每个 makeFSA的伪构造函数则是返回一个指向对象的指针（指向的对象都是惟一的，不相同的）。也就是说允许建立的FSA对象数量没有限制。</div><div>可是使用智能指针，防止内存泄漏</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">auto_ptr&lt;FSA&gt; pfsa1(FSA::makeFSA());  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">auto_ptr&lt;FSA&gt; pfsa2(FSA::makeFSA(*pfsa1));</span></div></div><div><br/></div><ul><li><div>允许对象来去自由</div></li></ul><div>thePrinter函数封装对单个对象的访问，以便把Printer对象的数量限制为一个，导致我们不能这样写代码</div><div>建立 Printer 对象 p1;  </div><div>使用 p1;  </div><div>释放 p1;  </div><div>建立Printer 对象 p2;</div><div>使用 p2;  </div><div>释放 p2;  </div><div><br/></div><div>我们将对象计数的代码和伪造构造函数的代码放在一起</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class Printer {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  class TooManyObjects{};  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  // 伪构造函数</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  static Printer * makePrinter();  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">~Printer();  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  void submitJob(const PrintJob&amp; job);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  void reset();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  void performSelfTest();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">private:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  static size_t numObjects;  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  Printer();  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  Printer(const Printer&amp; rhs);        //我们不定义这个函数<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">因为不允许<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">进行拷贝</span></span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};                </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><br/></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">size_t Printer::numObjects = 0;  </span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Printer::Printer()</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span> <span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">       </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">if (numObjects &gt;= 1) {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    throw TooManyObjects();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  }  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  继续运行正常的构造函数;  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ++numObjects;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Printer * Printer::makePrinter()</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{ return new Printer; }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><br/></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Printer p1;                               // 错误! 缺省构造函数是private</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Printer *p2 =</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  Printer::makePrinter();                   // 正确, 间接调用缺省构造函数</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Printer p3 = *p2; // 错误! 拷贝构造函数是 private</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">p2-&gt;performSelfTest();                   // 所有其它的函数都可以</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">p2-&gt;reset();                             // 正常调用  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">...  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">delete p2;                                // 避免内存泄漏，</span></div></div><div>该方法也能推广到任意数量，引入一个常量即可</div><div><br/></div><ul><li><div>一个具有对象计数功能的基类</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">template&lt;class BeingCounted&gt;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class Counted {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  class TooManyObjects{};                     // 用来抛出异常  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  static int objectCount() { return numObjects; }  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">protected:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  Counted();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  Counted(const Counted&amp; rhs);  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ~Counted() { --numObjects; }  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">private:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">atic int numObjects;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  static const size_t maxObjects;  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  void init();                                // 避免构造函数的</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};                                            // 代码重复  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">template&lt;class BeingCounted&gt;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Counted&lt;BeingCounted&gt;::Counted()</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{ init(); }  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">template&lt;class BeingCounted&gt;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Counted&lt;BeingCounted&gt;::Counted(const Counted&lt;BeingCounted&gt;&amp;)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{ init(); }  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">template&lt;class BeingCounted&gt;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">void Counted&lt;BeingCounted&gt;::init()</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  if (numObjects &gt;= maxObjects) throw TooManyObjects();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ++numObjects;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div></div><div><br/></div><div>让printer继承于counter模板</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class Printer: private Counted&lt;Printer&gt; {        //因为除了编写者，没人关心实现细节</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  // 伪构造函数</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  static Printer * makePrinter();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  static Printer * makePrinter(const Printer&amp; rhs);  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ~Printer();  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  void submitJob(const PrintJob&amp; job);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  void reset();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  void performSelfTest();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  using Counted&lt;Printer&gt;::objectCount;     // 因为用了private继承，为了恢复public权限</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  using Counted&lt;Printer&gt;::TooManyObjects;  // 同上</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">private:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  Printer();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  Printer(const Printer&amp; rhs);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div></div><div><br/></div></div></span>
</div></body></html> 