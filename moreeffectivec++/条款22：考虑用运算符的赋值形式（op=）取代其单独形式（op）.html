<html>
<head>
  <title>条款22：考虑用运算符的赋值形式（op=）取代其单独形式（op）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/6.1.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1568"/>
<h1>条款22：考虑用运算符的赋值形式（op=）取代其单独形式（op）</h1>

<div>
<span><div><span style="font-size: 14pt;">条款22：考虑用运算符的赋值形式（op=）取代其单独形式（op）</span></div><div><br/></div><div><span style="font-size: 10pt;">就c++来说，用户自定义类型，operator+、operator=和operator-没有任何关系，需要自己定义。</span></div><div><span style="font-size: 10pt;">一个好方法是operator的单独形式（operator+）根据operator的赋值形式（operator+=）实现</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class Rational {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  Rational&amp; operator+=(const Rational&amp; rhs);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  Rational&amp; operator-=(const Rational&amp; rhs);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};</span></div><div><br/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const Rational operator+(const Rational&amp; lhs,</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                         const Rational&amp; rhs)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  return Rational(lhs) += rhs;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// operator- 根据 operator -= 来实现</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const Rational operator-(const Rational&amp; lhs,</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                         const Rational&amp; rhs)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  return Rational(lhs) -= rhs;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div></div><div>如果不介意把operator的单独形式放在全局域里，可以使用模板来代替</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">template&lt;class T&gt;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const T operator+(const T&amp; lhs, const T&amp; rhs)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  return T(lhs) += rhs;                   </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">template&lt;class T&gt;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const T operator-(const T&amp; lhs, const T&amp; rhs)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  return T(lhs) -= rhs;                      </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}  </span></div></div><div>三个效率问题：</div><div>（1）总的来说 operator 的赋值形式比其单独形式效率更高，因为单独形式要返回一个新对象，从而在临时对象的构造和释放上有一些开销。operator 的赋值形式把结果写到左边的参数里，因此不需要生成临时对象来容纳 operator的返回值。</div><div>（2）提供 operator 的赋值形式的同时也要提供其标准形式，允许类的客户端在便利与效率上做出折衷选择。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//客户可以</div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Rational a, b, c, d, result;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">...</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">result = a + b + c + d; // 可能用了 3个临时对象</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">//也可以</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">result = a;                                  //不用临时对象</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">result += b;                                 //不用临时对象</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">result += c;                                 //不用临时对象</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">result += d;                                 //不用临时对象</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><br/></span></div></div><div>（3）operator 单独形式的实现。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">template&lt;class T&gt;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const T operator+(const T&amp; lhs, const T&amp; rhs)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{ return T(lhs) += rhs; }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">//T（lhs）调用了T的拷贝构造函数，建立了临时对象</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><br/></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">template&lt;class T&gt;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const T operator+(const T&amp; lhs, const T&amp; rhs)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">T result(lhs); // 拷贝 lhs 到 result 中</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">return result += rhs; // rhs 与它相加并返回结果</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">//包含了一个命名对象result，意味着不能再operator+里使用返回值优化（条款20），上一种方法可以</span></div><div><br/></div></div><div><br/></div><div>做为一个库程序设计者，应该两者都提供，做为一个应用程序的开发者，在优先考虑性能时你应该考虑考虑用operator赋值形式代替单独形式。</div></span>
</div></body></html> 