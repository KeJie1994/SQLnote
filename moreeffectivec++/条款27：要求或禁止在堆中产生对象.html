<html>
<head>
  <title>条款27：要求或禁止在堆中产生对象</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/6.1.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1592"/>
<h1>条款27：要求或禁止在堆中产生对象</h1>

<div>
<span><div><div><font style="font-size: 14pt;">条款27：要求或禁止在堆中产生对象</font></div><div><br/></div><ul><li><div>要求在堆中建立对象</div></li></ul><div>为了执行这种限制，你必须找到一种方法禁止以调用“new”以外的其它手段建立对象。非堆对象（non-heap object），在定义它的地方被自动构造，在生存时间结束时自动被释放，所以只要禁止使用隐式的构造函数和析构函数，就可以实现这种限制。</div><div>    最好让析构函数成为 private，让构造函数成为 public，利用伪析构函数。</div><div>   <br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class UPNumber {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  UPNumber();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  UPNumber(int initValue);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  UPNumber(double initValue);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  UPNumber(const UPNumber&amp; rhs);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  // 伪析构函数 (一个const 成员函数， 因为</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 即使是 const对象也能被释放。)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  void destroy() const { delete this; }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">private:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ~UPNumber();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">UPNumber n;    //错误，<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">但是<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">当它的析构函数被隐式地<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">调用时，就不合法了</span></span></span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">UPNumber *p = new UPNumber;          //正确</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">delete p;<span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    //<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">错误! 试图调用<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">private 析构函数<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">正确</span></span></span></span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">p-&gt;destroy();                        // 正确</span></div></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">另一种方法是把全部的构造函数声明为private</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><br/></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">通过限制类的析构函数或构造函数，该方法也禁止了继承和包含</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class UPNumber { ... };              // 声明析构函数或构造函数</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                                     // 为private</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class NonNegativeUPNumber:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  public UPNumber { ... };           // 错误! 析构函数或</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                                     //构造函数不能编译</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class Asset {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">private:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  UPNumber value;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...                                // 错误! 析构函数或</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                                     //构造函数不能编译</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};</span></div></div><div>解决方法为析构函数声明为protected，构造函数还是public，可以解决继承问题，包含对象的类改为包含对象的指针即可</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class UPNumber { ... }; // 声明析构函数为 protected</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class NonNegativeUPNumber:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  public UPNumber { ... };           // 现在正确了; 派生类</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                                     // 能够访问</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                                     // protected 成员</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class Asset {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  Asset(int initValue);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ~Asset();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">private:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  UPNumber *value;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Asset::Asset(int initValue)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">: value(new UPNumber(initValue))      // 正确</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{ ... }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Asset::~Asset()</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{ value-&gt;destroy(); }                 // 也正确</span></div></div><div><br/></div><ul><li><div>判断一个对象是否在堆中</div></li></ul><div>NonNegativeUPNumber 对象 n中的 UPNumber 部分无法判断是否在堆中</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">NonNegativeUPNumber *n1 =</span><span style="font-family: Monaco; font-size: 9pt;"> new NonNegativeUPNumber;            // 在堆中</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">NonNegativeUPNumber n2;               //不再堆中</span></div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class UPNumber {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  // 如果建立一个非堆对象，抛出一个异常</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  class HeapConstraintViolation {};</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  static void * operator new(size_t size);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  UPNumber();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">private:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  static bool onTheHeap;                 //在构造函数内，指示</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                                         // 对象是否被构造在</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...                                    // 堆上</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// obligatory definition of class static</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">bool UPNumber::onTheHeap = false;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">void *UPNumber::operator new(size_t size)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  onTheHeap = true;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  return ::operator new(size);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">UPNumber::UPNumber()</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  if (!onTheHeap) {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    throw HeapConstraintViolation();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  proceed with normal construction here;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  onTheHeap = false;                    // 为下一个对象清除标记</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div></div><div>这样写会出现问题，但是会出现问题</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">UPNumber *numberArray = new UPNumber[100];</span></div></div><div>所以 100 个构造函数中只有第一次调用构造函数前把 onTheHeap 设置为 true。当调用第二个构造函数时，会抛出一个异常。</div><div><br/></div><div>程序的地址空间被做为线性地址管理，程序的栈从地址空间的顶部向下扩展，堆则从底部向上扩展：</div><div><img src="条款27：要求或禁止在堆中产生对象_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 不正确的尝试，来判断一个地址是否在堆中</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">bool onHeap(const void *address)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  char onTheStack;                   // 局部栈变量</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  return address &lt; &amp;onTheStack;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div></div><div>如果参数 address 的地址小于 onTheStack 的地址，它就不会在栈上，而是肯定在堆上。</div><div>但是忘记了还有静态变量啊，一般位于最底部</div><div><img src="条款27：要求或禁止在堆中产生对象_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">void allocateSomeObjects()</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  char *pc = new char;               // 堆对象: onHeap(pc)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 将返回 true</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  char c;                            // 栈对象: onHeap(&amp;c)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 将返回 false</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  static char sc;                    // 静态对象: onHeap(&amp;sc)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 将返回 true</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div></div><div><br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class HeapTracked {                  // 混合类; 跟踪</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:                              // 从operator new返回的ptr</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  class MissingAddress{};            // 异常类，见下面代码</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  virtual ~HeapTracked() = 0;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  static void *operator new(size_t size);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  static void operator delete(void *ptr);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  bool isOnHeap() const;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">private:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  typedef const void* RawAddress;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  static list&lt;RawAddress&gt; addresses;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><br/></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">HeapTracked::~HeapTracked() {}</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">void * HeapTracked::operator new(size_t size)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  void *memPtr = ::operator new(size);  // 获得内存</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">addresses.push_front(memPtr); // 把地址放到 list的前端</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  return memPtr;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">void HeapTracked::operator delete(void *ptr)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  //得到一个 &quot;iterator&quot;，用来识别list元素包含的ptr；</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  //有关细节参见条款35</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  list&lt;RawAddress&gt;::iterator it =</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    find(addresses.begin(), addresses.end(), ptr);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  if (it != addresses.end()) {       // 如果发现一个元素</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    addresses.erase(it);             //则删除该元素</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    ::operator delete(ptr);          // 释放内存</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  } else {                           // 否则</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">throw MissingAddress(); // ptr就不是用 operator new</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  }                                  // 分配的，所以抛出一个异常</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">bool HeapTracked::isOnHeap() const</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  // 得到一个指针，指向*this占据的内存空间的起始处，</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  // 有关细节参见下面的讨论</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  const void *rawAddress = dynamic_cast&lt;const void*&gt;(this);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 在 operator new返回的地址 list中查到指针</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  list&lt;RawAddress&gt;::iterator it =</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    find(addresses.begin(), addresses.end(), rawAddress);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  return it != addresses.end();      // 返回it是否被找到</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}  </span></div></div><div><br/></div><ul><li><div>禁止堆对象</div></li></ul><div>三种情况：对象被直接实例化；对象做为派生类的基类被实例化；对象被嵌入到其它对象内。</div><div>（1）对象被直接实例化</div><div>在类中重新声明operator new，并声明为private</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class UPNumber {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">private:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  static void *operator new(size_t size);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  static void operator delete(void *ptr);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><br/></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">UPNumber n1;                         // okay</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">static UPNumber n2;                  // also okay</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">UPNumber *p = new UPNumber;          // error! attempt to call</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                                     // private operator new</span></div></div><div>（2）对象做为派生类的基类被实例化</div><div>继承于上述的类，因为 operator new 和 operator delete 是自动继承的，如果 operator new 和 operator delete 没有在派生类中被声明为 public它们就会继承基类中 private 的版本</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class UPNumber { ... };             // 同上</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class NonNegativeUPNumber:          //假设这个类</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public UPNumber { //没有声明 operator new</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">NonNegativeUPNumber n1;             // 正确</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">static NonNegativeUPNumber n2;      // 也正确</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">NonNegativeUPNumber *p =            // 错误! 试图调用</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  new NonNegativeUPNumber;          // private operator new</span></div></div><div>（3）对象被嵌入到其它对象内</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class Asset {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  Asset(int initValue);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">private:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  UPNumber value;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Asset *pa = new Asset(100);          // 正确, 调用</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                                     // Asset::operator new 或</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                                     // ::operator new, 不是</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                                     // UPNumber::operator new</span></div></div><div><br/></div></div></span>
</div></body></html> 