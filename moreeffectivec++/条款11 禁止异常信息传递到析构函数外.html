<html>
<head>
  <title>条款11 禁止异常信息传递到析构函数外</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/6.1.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1550"/>
<h1>条款11 禁止异常信息传递到析构函数外</h1>

<div>
<span><div><font style="font-size: 12pt;">条款11 禁止异常信息传递到析构函数外</font></div><div><br/></div><div>在有两种情况下会调用析构函数。第一种是在正常情况下删除一个对象，例如对象超出了作用域或被显式地 delete。第二种是异常传递的堆栈辗转开解（stack-unwinding）过程中，由异常处理系统删除一个对象。</div><div>在上述两种情况下，调用析构函数时异常可能处于激活状态也可能没有处于激活状态。遗憾的是没有办法在析构函数内部区分出这两种情况。因此在写析构函数时你必须保守地假设有异常被激活。因为如果在一个异常被激活的同时，析构函数也抛出异常，并导致程序控制权转移到析构函数外，C++将调用terminate函数。这个函数的作用正如其名字所表示的：它终止你程序的运行，而且是立即终止，甚至连局部对象都没有被释放。</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//Session类关心计算机开始一直到注销系统位置这段期间的某种东西，每个Session对象关注的是它建立与示范的时间</div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class Session </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>    </span>public:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>    </span>  Session();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  <span>    </span>~Session();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>    </span>  ...  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>    </span>private:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"> <span>    </span> static void logCreation(Session *objAddr);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"> <span>    </span> static void logDestruction(Session *objAddr);  //分别表示对象建立与示范</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};</span></div><div><font face="Monaco">Session::~Session()</font></div><div><font face="Monaco">{</font></div><div><font face="Monaco"><span>    logDestruction();</span><br/></font></div><div><font face="Monaco">}</font></div><div><font face="Monaco"><br/></font></div><div><font face="Monaco">//<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">如果 logDestruction 抛出一个异常<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">异常,没</span></span></font><span style="font-family: Monaco; font-size: 9pt;">有被Session 的析构函数捕获住，所以它被传递到析构函数的调用者那里。但是如果析构函</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">数本身的调用就是源自于某些其它异常的抛出，那么terminate 函数将被自动调用，彻底终</span><span style="font-family: Monaco; font-size: 9pt;">止你的程序。</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">你必</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">须防止在 logDestruction 内抛出的异常传递到 Session 析构函数的外面。唯一的方法是用</span><span style="font-family: Monaco; font-size: 9pt;">try 和catch blocks。</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Session::~Session()</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  try {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    logDestruction(this);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  catch (...) </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>    </span>{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    cerr  &lt;&lt; &quot;Unable to log destruction of Session object &quot;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">          &lt;&lt; &quot;at address &quot;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">          &lt;&lt; this</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">          &lt;&lt; &quot;.\n&quot;;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">   }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">//但是如果catch中调用operator&lt;&lt;时有异常抛出，同样会转递到Session析构函数的外面</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">//我们必须在释放Session时忽略到所有它抛出的异常</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Session::~Session()</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  try {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    logDestruction(this);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  catch (...) {  }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">//catch表面上没做任何事情，这是假象，阻止了任何从logDestruction抛出的异常传递到析构函数外面</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><br/></span></div></div><div><br/></div><div>不允许异常传递到析构函数外面还有第二个原因。如果一个异常被析构函数抛出而没有在函数内部捕获住，那么析构函数就不会完全运行（它会停在抛出异常的那个地方上）。如果析构函数不完全运行，它就无法完成希望它做的所有事情。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">我们对session 类做一</span><span style="font-family: Monaco; font-size: 9pt;">个修改，在建立 session 时启动一个数据库事务，终止session时结束这个任务</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Session::Session()          // 为了简单起见，,</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{                           // 这个构造函数没有</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                            // 处理异常</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  logCreation(this);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  startTransaction();       // 启动 database transaction</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Session::~Session()</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  logDestruction(this);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">endTransaction(); // 结束 database transaction</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div></div><div>如果在这里logDestruction抛出一个异常，在session构造函数内启动的transaction就没有被终止。我们也许能够通过重新调整 session 析构函数内的函数调用顺序来消除问题，但是如果 endTransaction 也抛出一个异常，我们除了回到使用 try和 catch 外，别无选择。</div></span>
</div></body></html> 