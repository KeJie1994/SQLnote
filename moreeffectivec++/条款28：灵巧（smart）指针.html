<html>
<head>
  <title>条款28：灵巧（smart）指针</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/6.1.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1598"/>
<h1>条款28：灵巧（smart）指针</h1>

<div>
<span><div><div>条款28：灵巧（smart）指针</div><div><br/></div><ul><li><div>构造和析构。你可以决定建立灵巧指针时应该怎么做。通常赋给灵巧指针缺省值0，避免出现令人头疼的未初始化的指针。当指向某一对象的最后一个灵巧指针被释放</div></li></ul><div>时，某些灵巧指针被设计成负责删除它们指向的对象。这样做对防止资源泄漏很有帮助。</div><ul><li><div>拷贝和赋值。你能对拷贝灵巧指针或有灵巧指针参与的赋值操作进行控制。对于某些类型的灵巧指针来说，期望的行为是自动拷贝它们所指向的对象或用对这些对象</div></li></ul><div>进行赋值操作，也就是进行 deep copy(深层拷贝)。对于其它的一些灵巧指针来说，仅仅拷贝指针本身或对指针进行赋值操作。还有一部分类型的灵巧指针根本就不允许这些操作。无论你认为应该如何去做，灵巧指针始终受你的控制。</div><ul><li><div>Dereferencing(取出指针所指东西的内容)。当用户引用被灵巧指针所指的对象，会发生什么事情呢？你可以自行决定。</div></li></ul><div><br/></div></div><div>//看下如何使用smart指针，假设在一个分布式系统中（对象一部分在本地，一部分在异地），访问本地简单，访问外地需要调用RPC，然而我们需要采用相同的处理方法。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">template&lt;class T&gt;                    // 指向位于分布式 DB（数据库）</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class DBPtr {                       </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:                               </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  DBPtr(T *realPtr = 0);             // 建立灵巧指针，指向<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">由一个本地 dumb pointer<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">给出的 DB 对象</span></span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  DBPtr(DataBaseID id);              // 建立灵巧指针，<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">指向一个DB对象，<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">具有惟一的 DB识别符</span></span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};                                </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class Tuple {                        // 数据库元组类</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:                              </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  void displayEditDialog();          // 显示一个图形对话框，<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">允许用户编辑元组。</span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  bool isValid() const;         // 返回*this 是否通过了<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">合法性验证</span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};        </span></div><div><br/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 这个类模板用于在修改T 对象时进行日志登记。</span>            </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">template&lt;class T&gt;</span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class LogEntry {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  LogEntry(const T&amp; objectToBeModified);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ~LogEntry();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">void editTuple(DBPtr&lt;Tuple&gt;&amp; pt)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  LogEntry&lt;Tuple&gt; entry(*pt);        // 为这个编辑操作登记日志</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  do {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    pt-&gt;displayEditDialog();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  } while (pt-&gt;isValid() == false);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span> <span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">              </span></div></div><div>在 editTuple 中被编辑的元组物理上可以位于本地也可以位于远程，但是编写editTuple的程序员不用关心这些事情。灵巧指针类隐藏了系统的这些方面。就程序员所关心的方面而言，通过灵巧指针对象进行访问元组，除了如何声明它们不同外，其行为就像一</div><div>个内建指针。</div><div><br/></div><div>（1）灵巧指针的构造、赋值和析构</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">template&lt;class T&gt;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class auto_ptr {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  auto_ptr(T *ptr = 0): pointee(ptr) {}</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  auto_ptr(auto_ptr&lt;T&gt;&amp; rhs);        // 拷贝构造函数</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  auto_ptr&lt;T&gt;&amp;  <span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">operator=(auto_ptr&lt;T&gt;&amp; rhs); </span> // 赋值<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">操作符</span></span></div><div><span style="font-family: Monaco; font-size: 9pt;">  ~auto_ptr() { delete pointee; }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">private:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  T *pointee;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};</span></div><div><br/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">template&lt;class T&gt;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">auto_ptr&lt;T&gt;::auto_ptr(auto_ptr&lt;T&gt;&amp; rhs)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  pointee = rhs.pointee;             // 把*pointee的所有权<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">传递到 *this</span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  rhs.pointee = 0;                   // rhs不再拥有<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">任何东西</span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}         </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">template&lt;class T&gt;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">auto_ptr&lt;T&gt;&amp; auto_ptr&lt;T&gt;::operator=(auto_ptr&lt;T&gt;&amp; rhs)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  if (this == &amp;rhs)                  // 如果这个对象自我赋值<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">什么也不要做</span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    return *this; </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  delete pointee;                    // 删除现在拥有的对象</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  pointee = rhs.pointee;             // 把*pointee的所有权</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  rhs.pointee = 0;                   // 从 rhs 传递到 *this</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  return *this;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div></div><div>注意：auto_ptr不要使用值传递，否则会由于所有权转移，被析构。要用引用传递。</div><div><br/></div><div>（2）实现Dereference 操作符</div><div>让我们把注意力转向灵巧指针的核心部分，operator*和 operator-&gt; 函数。</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">template&lt;class T&gt;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">T&amp; SmartPtr&lt;T&gt;::operator*() const</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  perform &quot;smart pointer&quot; processing;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  return *pointee;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div></div><div>注意返回类型是一个引用，返回对象会出现灾难性后果。pointee不仅可以指向T类型对象，也可以指向T的派生对象（返回的也要是派生类对象，否则会发生切割）。</div><div>灵巧指针不支持虚函数。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">template&lt;class T&gt;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">T* SmartPtr&lt;T&gt;::operator-&gt;() const</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  perform &quot;smart pointer&quot; processing;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  return pointee;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div></div><div><br/></div><div>（3）测试灵巧指针是否为 NULL</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">SmartPtr&lt;TreeNode&gt; ptn;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">...</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">if (ptn == 0) ...                    // error!</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">if (ptn) ...                         // error!</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">if (!ptn) ...                        // error!</span></div></div><div>加入成员函数</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">operator void*();<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 如果灵巧指针为 null，<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">返回0， 否则返回<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">非0。</span></span></span></span></div></div><div>此时上述代码均通过 ，但是会出现问题，不同类型的只能指针，居然也能相等</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">SmartPtr&lt;Apple&gt; pa;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">SmartPtr&lt;Orange&gt; po;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">...</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">if (pa == po) ...                    // 这能够被成功编译!</span></div></div><div>都被隐式转换为了void*指针。</div><div><br/></div><div>解决方法为重载operator！（）</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">bool operator!() const;  <span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 当且仅当灵巧指针是<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">空值，返回 true。</span></span></span></div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">用户程序如下所示：</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">SmartPtr&lt;TreeNode&gt; ptn;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">...</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">if (!ptn) {                          // 正确</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...                                // ptn 是空值</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">else {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...                                // ptn不是空值</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">if (ptn == 0) ...                    // 仍然错误</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">if (ptn) ...                         // 也是错误的</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">if (!pa == !po) ...                 // 能够编译</span></div></div><div>iostream库的实现除了提供void*隐式的类型转换，也有 operator!函数</div><div>（4）把灵巧指针转变成dumb指针</div><div>添加一个隐式类型转换操作符的函数</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">operator T*() { return pointee; }</span></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">void normalize(Tuple *pt);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">DBPtr&lt;Tuple&gt; pt;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">normalize(pt);                       // 能够运行</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">并且这个函数也消除了测试空值的问题：</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">if (pt == 0) ...                     // 正确, 把pt转变成</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                                     // Tuple*</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">if (pt) ...                          // 同上</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">if (!pt) ...                         // 同上 </span></div></div><div><br/></div><div>（5）灵巧指针和继承类到基类的类型转换</div><div>假设这样一种情况</div><div><img src="条款28：灵巧（smart）指针_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>class SmartPtr&lt;Cassette&gt; {</div><div>public:</div><div>  operator SmartPtr&lt;MusicProduct&gt;()</div><div>  { return SmartPtr&lt;MusicProduct&gt;(pointee); }</div><div>  ...</div><div>private:</div><div>  Cassette *pointee;</div><div>};</div><div>class SmartPtr&lt;CD&gt; {</div><div>public:</div><div>  operator SmartPtr&lt;MusicProduct&gt;()</div><div>  { return SmartPtr&lt;MusicProduct&gt;(pointee); }</div><div>  ...</div><div>private:</div><div>  CD *pointee;</div><div>};</div></span>
</div></body></html> 