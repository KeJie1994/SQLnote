<html>
<head>
  <title>条款10：在构造函数中防止资源泄漏</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/6.1.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1548"/>
<h1>条款10：在构造函数中防止资源泄漏</h1>

<div>
<span><div>条款10：在构造函数中防止资源泄漏</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Image//图像数据</div><div>{</div><div>    public:</div><div>        Image(const string&amp; imageDataFileName);</div><div>};</div><div>class AudioClip//声音数据</div><div>{</div><div>    public:</div><div>      AudioClip(const string&amp; audioDataFileName);  </div><div>};</div><div>class PhoneNumber{...};</div><div><br/></div><div>class BookEntry //通讯录中的条目</div><div>{</div><div>    public:</div><div>        BookEntry(const string&amp; name,</div><div>                  const string&amp; address=&quot;&quot;,</div><div>                  const string&amp; imageFileName=&quot;&quot;,</div><div>                  const string&amp; audioClipFileName=&quot;&quot;);</div><div>        ~BookEntry();</div><div>        void addPhoneNumber(const PhoneNumber&amp; number);</div><div>    ...</div><div>    private:</div><div>        string theNmae;</div><div>        string theAddress;</div><div>        list&lt;PhoneNumber&gt; thePhones;</div><div>        Image* theImage;</div><div>        AudioClip* theAudioClip;</div></div><div><br/></div><div>由于通讯录的每个条目都有数据，需要带参的构造函数</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">BookEntry(const string&amp; name,</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                  const string&amp; address=&quot;&quot;,</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                  const string&amp; imageFileName=&quot;&quot;,</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                  const string&amp; audioClipFileName=&quot;&quot;)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">：theName(name),theAddress(adderss),</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    theImage(0),theAudioClip(audioClipName)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    if(imageFileName!=&quot;&quot;)</span></div><div>  {</div><div>    <span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">theImage=new Image(imageFileName);</span></div><div>  }</div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    if(audioClipFileName!=&quot;&quot;)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">        theAudioClip=new AudioClpi(audioClipFileName);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    }</span></div><div><br/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><br/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">BookEntry:~BookEntry()</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    delete theImage;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    delete theAudioClip;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><br/></span></div><div>//假如构造函数抛出异常时,列如</div><div>if(audioClipFileName!=&quot;&quot;)</div><div>{</div><div><span>    theAudioClip=new AudioClip(audioClipName);</span><br/></div><div>}</div><div>//可能因为operator new不能给AudioClip分配足够的内存，可能是构造函数抛出异常，该异常会传递到BookEntry的对象构造时，此时theImgae对象应该有BookEntry来删除，然而~BookEntry（）根本不会被调用。</div><div>注意：c++仅仅能删除被完全构造的对象，只有一个对象的构造函数完全运行完毕时，这个对象才被完全的构造。</div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//如果一个BookEntry对象b做为局部对象建立，如</div><div>void testBookEntryClass()</div><div>{</div><div><span>    BookEntry b(&quot;<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Addison-Wesley Publishing Company&quot;,</span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span>  &quot;One Jacob Way, Reading, MA 01867&quot;);  </span></div><div>}</div><div>//假设构造b时一个异常被抛出，b的析构函数不会调用，如果试图采取主动手段处理异常，异常发生时调用delete</div><div>void testBookEntryClass()</div><div>{</div><div><span>    BookEntry *pb=0;</span><br/></div><div><span><span>    try</span><br/></span></div><div><span><span>    {</span><br/></span></div><div><span>    </span><span>    pb=new BookEntry<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">(&quot;</span><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Addison-Wesley Publishing Company&quot;,</span></span></div><div><span style="font-family: Monaco; font-size: 9pt;"><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span>&quot;One Jacob Way, Reading, MA 01867&quot;); </span></div><div><span style="font-family: Monaco; font-size: 9pt;"><span>    </span><span>    </span><span>    </span><span>    ...</span><br/></span></div><div><span><span>    }</span><br/></span></div><div><span><span>    catch(...)</span><br/></span></div><div><span><span>    {</span><br/></span></div><div><span><span>    </span><span>    delete pb;</span><br/></span></div><div><span><span>    </span><span>    throw;//传递异常给调用者</span><br/></span></div><div><span><span>    }</span><br/></span></div><div><span><span>    delete pb;</span><br/></span></div><div>}</div><div>//如果BookEntry构造函数里为Image分配的内存丢失，这是因为new操作未完成，程序不会对pb进行复制，pb为一个空值，catch中删除它没有作用</div></div><div><br/></div><div>C++拒绝为没有完成构造操作的对象调用析构函数是有一些原因的，而不是故意为你制造困难。原因是：在很多情况下这么做是没有意义的，甚至是有害的。如果为没有完成构造操作的对象调用析构函数，析构函数如何去做呢？仅有的办法是在每个对象里加入一些字节来指示构造函数执行了多少步？然后让析构函数检测这些字节并判断该执行哪些操作。这样的记录会减慢析构函数的运行速度，并使得对象的尺寸变大。C++避免了这种开销，但是代价是不能自动地删除被部分构造的对象。</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//最好的解决方法利用资源管理对象</div><div>class BookEntry</div><div>{</div><div><span>    </span>public:</div><div><span>    ...</span><br/></div><div><span><span>    private:</span><br/></span></div><div><span><span>    ...</span><br/></span></div><div><span><span>    const auto_ptr&lt;Image&gt;  theImahe;</span><br/></span></div><div><span><span>    connst auto_ptr&lt;AudioClip&gt; theAudioClip;</span><br/></span></div><div>}</div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">BookEntry(const string&amp; name,</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                  const string&amp; address=&quot;&quot;,</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                  const string&amp; imageFileName=&quot;&quot;,</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                  const string&amp; audioClipFileName=&quot;&quot;)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>    </span><span>    </span><span>    </span><span>    :theName(name),theAddress(address),</span><br/></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span><span>    </span><span>    </span><span>    </span><span>     theImage(imageFileName!=&quot;&quot;?new Image(imageFileName:0),</span><br/></span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span><span>    </span><span>    </span><span>    </span><span>    theAudioClip(audioClipFileName!=&quot;&quot;?new AudioClip(audioClipFileName):0){}</span><br/></span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>//这里如果在初始化theAudioClip时抛出异常，theImage已经是一个被完全构造的对象，所以能自动删除</span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span><span> BookEntry：：~BookEntry（）</span><br/></span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>{</span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>}</span></span></div></div><div>综上所述，如果你用对应的 auto_ptr 对象替代指针成员变量，就可以防止构造函数在存在异常时发生资源泄漏，你也不用手工在析构函数中释放资源，并且你还能象以前使用非const指针一样使用const指针，给其赋值。</div></span>
</div></body></html> 