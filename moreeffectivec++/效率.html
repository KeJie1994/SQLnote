<html>
<head>
  <title>效率</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/6.1.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1560"/>
<h1>效率</h1>

<div>
<span><div><span style="font-size: 14pt;">效率</span></div><div><br/></div><div><span style="font-size: 14pt;">条款16：牢记80-20准则</span></div><div><span style="font-size: 10pt;">80－20 准则说的是大约 20％的代码使用了 80％的程序资源；大约 20%的代码耗用了大</span><span style="font-size: 10pt;">约 80％的运行时间；大约 20％的代码使用了 80％的内存；大约 20％的代码执行 80％的磁</span><span style="font-size: 10pt;">盘访问；80％的维护投入于大约 20％的代码上；</span></div><div><br/></div><div><span style="font-size: 14pt;">条款17：考虑使用lazy evaluation（懒惰计算法）</span></div><div><br/></div><div><span style="font-size: 10pt;"><span>    </span>当你还是一个孩子时，你的父母叫你整理房间。你如果象我一样，就会说“好的“，然后继续做你自己的事情。你不会去整理自己的房间。在你心里整理房间被排在了最后的位置，实际上直到你听见父母下到门厅来查看你的房间是否已被整理时，你才会猛跑进自己的房间里并用最快的速度开始整理。如果你走运，你父母可能不会来检查你的房间，那样的话你就能根本不用整理房间了。</span></div><div><span>    当你使用了 lazy evaluation 后，采</span>用此种方法的类将推迟计算工作直到系统需要这些计算的结果。如果不需要结果，将不用进行计算。</div><div><br/></div><div>（1）引用计数</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>String s1=&quot;Hello&quot;</div><div>String s2=s1</div></div><div>调用拷贝构造函数开销比较大，然而此时的s2并不需要这个值的拷贝，未被使用。懒惰能让s2与s1共享一个值，省掉new和拷贝字符的开销，对于下面只读数据没影响</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>cout&lt;&lt;s1;</div><div>cout&lt;&lt;s1+s2;</div></div><div>仅仅修改一个值，不是两个都修改，就不能懒惰了，拷贝给s2使用。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">s2.convertToUpperCase();</span></div></div><div><br/></div><div>（2）区别对待读取和写入</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">String s = &quot;Homer's Iliad&quot;;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">cout &lt;&lt; s[3];                         // 调用 operator[] 读取s[3]</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">s[3] = 'x';<span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>  </span> <span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">// 调用 operator[] 写入 s[3]</span></span></div></div><div>因为读取 reference-counted string 是很容易的，而写入这个 string则需要在写入前对该string值制作一个新拷贝。</div><div><br/></div><div>（3）Lazy Fetching（懒惰提取）</div><div><span>    </span>假设你的程序使用了一些包含许多字段的大型对象。这些对象的生存期超越了程序运行期，所以它们必须被存储在数据库里。每一个对都有一个唯一的对象标识符，用来从数据库中重新获得对象：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class LargeObject {                       <span>    </span><span>    </span> // 大型持久对象</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    LargeObject(ObjectID id);                // 从磁盘中恢复对象  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>    </span>const string&amp; field1() const; <span>    </span><span>    </span><span>   </span>// field 1 的值</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>    </span>int field2() const; <span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span>// field 2 的值</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"> <span>  </span> double field3() const;               <span>    </span>   // ...</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    const string&amp; field4() const;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    const string&amp; field5() const;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">   ...  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><br/></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">void restoreAndProcessObject(ObjectID id)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  LargeObject object(id);                  // 恢复对象  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div></div><div>对象实例很大时，数据库的操作开销很大，考虑</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">void restoreAndProcessObject(ObjectID id)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    LargeObject object(id);  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    if (object.field2() == 0)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>    </span>{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    cout &lt;&lt; &quot;Object &quot; &lt;&lt; id &lt;&lt; &quot;: null field2.\n&quot;;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"> <span>  </span>  }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div></div><div>懒惰法当需要某个数据时，这个数据才被从数据库中取回</div><div><br/></div><div>（4） Lazy Expression Evaluation(懒惰表达式计算)</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">template&lt;class T&gt;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class Matrix { ... };                         // for homogeneous matrices  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Matrix&lt;int&gt; m1(1000, 1000);                   // 一个 1000 ＊ 1000 的矩阵</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Matrix&lt;int&gt; m2(1000, 1000);                </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">...  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Matrix&lt;int&gt; m3 = m1 + m2;                     // m1＋m2</span></div></div><div>计算m1和m2的和，需要计算1000000次加法运算量太大，懒惰法会建立一个数据结构，表示m1和m2的和</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Matrix&lt;int&gt; m4(1000, 1000);  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">... // 赋给 m4一些值</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">m3 = m4 * m1;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">cout&lt;&lt;m3[4];</span></div></div><div>只计算m3的第四行</div><div>如果是cout&lt;&lt;m3，就需要全部计算</div><div><br/></div></span>
</div></body></html> 