<html>
<head>
  <title>条款20：协助完成返回值优化</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/6.1.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1566"/>
<h1>条款20：协助完成返回值优化</h1>

<div>
<span><div>条款20：协助完成返回值优化</div><div><br/></div><div>一个函数返回对象的函数很难有高效率，设计到调用对象内构造和析构函数</div><div><br/></div><div>例如</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class Rational {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  Rational(int numerator = 0, int denominator = 1);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  int numerator() const;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  int denominator() const;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const Rational operator*(const Rational&amp; lhs,</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                         const Rational&amp; rhs);</span></div></div><div>肯定会返回对象，。从效率的观点来看，你不应该关心函数返回的对象，你仅仅应该关心对象的开销。你所应该关心的是把你的努力引导到寻找减少返回对象的开销上来，而不是去消除对象本身。</div><div>比较合适的写法</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const Rational operator*(const Rational&amp; lhs,</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                         const Rational&amp; rhs)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">          return Rational(lhs.numerator() * rhs.numerator(),</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                      lhs.denominator() * rhs.denominator());</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div></div><div>这样能把临时对象拷贝给函数的返回值 ,返回 constructor argument 而不出现局部对象，这种方法还会给你带来很多开销，因为你仍旧必须为在函数内临时对象的构造和释放而付出代价，你仍旧必须为函数返回对象的</div><div>构造和释放而付出代价。但是你已经获得了好处。</div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;">条款21：通过重载避免隐式类型转换</font></div><div><font style="font-size: 14pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class UPInt {                       </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:                                      </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  UPInt();</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  UPInt(int value);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const UPInt operator+(const UPInt&amp; lhs, const UPInt&amp; rhs);  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">UPInt upi1, upi2;  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">...  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">UPInt upi3 = upi1 + upi2;</span></div></div><div>肯定能成功</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">upi3 = upi1 + 10;  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">upi3 = 10 + upi2;</span></div></div><div>也能成功，涉及到类型转换，会有临时对象对象的开销，想要消除，可以采用重载的方法</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const UPInt operator+(const UPInt&amp; lhs,      // add UPInt</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                      const UPInt&amp; rhs);     // and UPInt</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const UPInt operator+(const UPInt&amp; lhs,      // add UPInt</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                      int rhs);              // and int  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const UPInt operator+(int lhs,               // add int and</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                      const UPInt&amp; rhs);     // UPInt  </span></div></div><div>不能出现<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">const UPInt operator+(int lhs, int rhs);           // 错误!</span></div></div><div>在 C++中有一条规则是每一个重载的 operator 必须带有一个用户定义类型</div><div>（user-defined type）的参数</div><div><br/></div><div>不过，必须谨记80－20 规则（参见条款M16）。没有必要实现大量的重载函数，除非你有理由确信程序使用重载函数以后其整体效率会有显著的提高。</div></span>
</div></body></html> 