<html>
<head>
  <title>条款12：理解“抛出一个异常”与“传递一个参数”或“调用一个虚函数”间的差异</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/6.1.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1552"/>
<h1>条款12：理解“抛出一个异常”与“传递一个参数”或“调用一个虚函数”间的差异</h1>

<div>
<span><div><font style="font-size: 14pt;">条款12：理解“抛出一个异常”与“传递一个参数”或“调用一个虚函数”间的差异</font></div><div>1.</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//一个函数从流中读值到Widget中</div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">istream operator&gt;&gt;(istream&amp; s, Widget&amp; w);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">void passAndThrowWidget()</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  Widget localWidget;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  cin &gt;&gt; localWidget;          //传递localWidget到 operator&gt;&gt;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  throw localWidget;           // 抛出localWidget异常</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">//<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">当传递 localWidget 到函数 operator&gt;&gt;里，不用进行拷贝操作，而是把 operator&gt;&gt;内</span></span><span style="font-family: Monaco; font-size: 9pt;">的引用类型变量 w指向localWidget.。<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">不论通过传值捕获异常还是通过引用捕获，<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">都将进行lcalWidget的拷贝操作，也就说传递到catch</span></span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">子句中的是 localWidget的拷贝。否则接收到的是被析构的Widget。</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><br/></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">//即使不抛出的对象不对释放，也会进行拷贝，列如声明为static</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">void passAndThrowWidget()</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  static Widget localWidget;       </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                                   </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  cin &gt;&gt; localWidget;               </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  throw localWidget;               </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}                                   //进行拷贝操作</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">//<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">即使通过引用来捕获异常，</span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">也不能在catch块中修改localWidget；仅仅能修改localWidget 的拷贝。对异常对象进行</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">强制复制拷贝，这个限制有助于我们理解参数传递与抛出异常的第二个差异：抛出异常运行</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">速度比参数传递要慢。</span></div></div><div><br/></div><div>当异常对象被拷贝时，拷贝操作由拷贝函数完成的，该拷贝函数是对象的静态类型而不是动态类型对应的拷贝构造函数</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class Widget { ... };</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class SpecialWidget: public Widget { ... };</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">void passAndThrowWidget()</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  <span>  </span> SpecialWidget localSpecialWidget;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"> <span>    </span> ...</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>    </span>Widget&amp; rw = localSpecialWidget; // rw 引用 SpecialWidget</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>    </span>throw rw; //它抛出一个类型为 Widget</span><span style="font-family: Monaco; font-size: 9pt;">的异常</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div></div><div>这里抛出的异常时Widget，因为rw的静态类型使Widget。</div><div><br/></div><div>2 c++支持int到double 隐式类型转换</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">int i;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">double sqrtOfi = sqrt(i);//i悄悄转换为double类型</span></div></div><div>catch子句匹配类型异常时不会进行这样的转换</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void f(int value)</div><div>{</div><div><span>    try</span><br/></div><div><span><span>    {</span><br/></span></div><div><span><span>    </span><span>    if(someFunction())</span><br/></span></div><div><span><span>    </span><span>    { throw value;}</span><br/></span></div><div><span><span>    }</span><br/></span></div><div><span>    catch(double d) \\只处理double类型的异常</span><br/></div><div><span><span>    {...};</span><br/></span></div><div>}</div></div><div>抛出的int类型不会被捕获</div><div>只能进行两种类型转换，第一种是继承类与基类间的转换。一个用来捕获基类的catch子句也可以处理派生类类型的异常。第二种是允许从一个类型化指针（typed pointer）转变成无类型指针（untyped</div><div>pointer），所以带有const void* 指针的catch子句能捕获任何类型的指针类型异常</div><div><br/></div><div>3.注意匹配顺序</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">try {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">catch (logic_error&amp; ex) { // 这个 catch块 将捕获<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">所有的logic_error<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">异常, 包括它的派生类</span></span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...                                  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}                                      </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">catch (invalid_argument&amp; ex) {     // 这个块永远不会被执行<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">因为所有的</span><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">invalid_argument</span><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">异常 都被上面的</span><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">catch子句捕获。</span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...                                  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}                                     </span></div></div><div>如果一个处理派生类异常的 catch子句位于处理基类异常的 catch子句后面，编译器会发出警告。上述可以修改为</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">try {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">catch (invalid_argument&amp; ex) {          // 处理 invalid_argument<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"> 异常</span></span></div><div><br/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">catch (logic_error&amp; ex) {               // 处理所有其它的<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">logic_errors异常</span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...   </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div></div><div>综上所述，把一个对象传递给函数或一个对象调用虚拟函数与把一个对象做为异常抛出，这之间有三个主要区别。第一、异常对象在传递时总被进行拷贝；当通过传值方式捕获时，异常对象被拷贝了两次。对象做为参数传递给函数时不一定需要被拷贝。第二、对象做为异常被抛出与做为参数传递给函数相比，前者类型转换比后者要少（前者只有两种转换形式）。最后一点，catch 子句进行异常类型匹配的顺序是它们在源代码中出现的顺序，第一个类型匹配成功的 catch将被用来执行。当一个对象调用一个虚拟函数时，被选择的函数位于与对象类型匹配最佳的类里，即使该类不是在源代码的最前头。</div></span>
</div></body></html> 