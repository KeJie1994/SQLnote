<html>
<head>
  <title>效率</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/6.1.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1588"/>
<h1>效率</h1>

<div>
<span><div><span style="font-size: 14pt;">效率</span></div><div><br/></div><div><span style="font-size: 10pt;">你如何让构造函数和非成员函数具有虚拟函数的特点？你如何限制一个类的实例的数量？你如何防止在堆中建立对象呢？你如何又能确保把对象建立在堆中呢？其它一些类的成员函数无论何时被调用，你如何能建立一个对象并让它自动地完成一些操作？你如何能让不同的对象共享数据结构，而让每个使用者以为它们每一个都拥有自己的拷贝？你如何区分 operator[]的读操作和写操作？你如何建立一个虚函数，其行为特性依赖于不同对象的动态类型？</span></div><div><br/></div><div><span style="font-size: 14pt;">条款25：将构造函数和非成员函数虚拟化</span></div><div><br/></div><div>(1)从字面来看，谈论“虚拟构造函数”没有意义。当你有一个指针或引用，但是不知道其指向对象的真实类型是什么时，你可以调用虚拟函数来完成特定类型（type-specific）对象的行为。仅当你还没拥有一个对象但是你又确切地知道想要的对象的类型时，你才会调用构造函数。</div><div><br/></div><div>举例：假设你编写一个程序，用来进行新闻报道的工作，每一条新闻报道都由文字或图片组成</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class NLComponent {               //用于 newsletter components  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:                           // 的抽象基类  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...                             //包含至少一个纯虚函数</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class TextBlock: public NLComponent {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...                             // 不包含纯虚函数</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class Graphic: public NLComponent {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...                             // 不包含纯虚函数</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class NewsLetter {                // 一个 newsletter 对象</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:                           // 由NLComponent 对象</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...                             // 的链表组成</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">private:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  list&lt;NLComponent*&gt; components;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};</span></div></div><div><br/></div><div>对象NewLetter不运行时就会存储在磁盘上。为了能够通过位于磁盘的替代物来建立Newsletter 对象，让NewLetter的构造函数带有 istream 参数是一种很方便的方法。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class NewsLetter {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  NewsLetter(istream&amp; str);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">此构造函数的伪代码是这样的：</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">NewsLetter::NewsLetter(istream&amp; str)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  while (str) {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">从 str读取下一个component对象;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">把对象加入到 newsletter的 components对象的链表中去;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">或者，把这种技巧用于另一个独立出来的函数叫做readComponent，</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class NewsLetter {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">private:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  static NLComponent * readComponent(istream&amp; str);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">   ...</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  NewsLetter::NewsLetter(istream&amp; str)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    while (str) {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">        // 把readComponent返回的指针添加到components链表的最后，</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">        components.push_back(readComponent(str));</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div></div><div>所读取的数据建立了一个新对象，或是TextBlock 或是 Graphic。因为它能建立新对象，它的行为与构造函数相似，而且因为它能建立不同类型的对象，我们称它为虚拟构造函数。</div><div><br/></div><div>虚拟拷贝构造函数虚拟，拷贝构造函数能返回一个指针，指向调用该函数的对象的新拷贝。</div><div>我们基本不会这样写</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class NLComponent {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  // declaration of virtual copy constructor</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  virtual NLComponent * clone() const = 0;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class TextBlock: public NLComponent {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  virtual TextBlock * clone() const         // virtual copy</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  { return new TextBlock(*this); }          // constructor</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class Graphic: public NLComponent {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  virtual Graphic * clone() const            // virtual copy</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  { return new Graphic(*this); }             // constructor</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">注意：<span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">被派生</span></span><span style="font-size: 9pt; font-family: Monaco;">类重定义的虚拟函数不用必须与基类的虚拟函数具有一样的返回类型。如果函数的返回类型</span><span style="font-size: 9pt; font-family: Monaco;">是一个指向基类的指针（或一个引用），那么派生类的函数可以返回一个指向基类的派生类</span><span style="font-size: 9pt; font-family: Monaco;">的指针（或引用）。</span><span style="font-size: 9pt; font-family: Monaco;">这就是为什么 TextBlock的 clone函数能够返回TextBlock*和Graphic的clone</span><span style="font-size: 9pt; font-family: Monaco;">能够返回Graphic*的原因</span></div></div><div><br/></div><div>在NLComponent中的虚拟拷贝构造函数能让实现NewLetter的(正常的)拷贝构造函数变得很容易</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class NewsLetter {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  NewsLetter(const NewsLetter&amp; rhs);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">private:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  list&lt;NLComponent*&gt; components;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">NewsLetter::NewsLetter(const NewsLetter&amp; rhs)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><br/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  for (list&lt;NLComponent*&gt;::const_iterator it =rhs.components.begin();it!=rhs.components.end();++it)</span></div><div> {</div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    components.push_back((*it)-&gt;clone());</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  }</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div></div><div>(2)非成员函数也不能成为真正的虚拟函数</div><div>假设你想为TextBlock和 Graphic对象实现一个输出操作符。显而易见的方法是虚拟化这个输出操作符。但是输出操作符是 operator&lt;&lt;，函数把 ostream&amp;做为它的左参数</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class NLComponent {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  // 对输出操作符的不寻常的声明</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  virtual ostream&amp; operator&lt;&lt;(ostream&amp; str) const = 0;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class TextBlock: public NLComponent {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  // 虚拟输出操作符(同样不寻常)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  virtual ostream&amp; operator&lt;&lt;(ostream&amp; str) const;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class Graphic: public NLComponent {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  // 虚拟输出操作符 (让就不寻常)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  virtual ostream&amp; operator&lt;&lt;(ostream&amp; str) const;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">TextBlock t;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Graphic g;  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><br/></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">t &lt;&lt; cout;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">g &lt;&lt; cout;</span></div></div><div>与输出操作符一般的用发相反</div><div>另一种方法是为打印操作声明一个虚拟函数（例如 print）把它定义在 TextBlock 和Graphic类里。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class NLComponent {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  virtual ostream&amp; print(ostream&amp; s) const = 0;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class TextBlock: public NLComponent {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  virtual ostream&amp; print(ostream&amp; s) const;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">class Graphic: public NLComponent {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">public:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  virtual ostream&amp; print(ostream&amp; s) const;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  ...  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">};  </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">inline</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">ostream&amp; operator&lt;&lt;(ostream&amp; s, const NLComponent&amp; c)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">{</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">  return c.print(s);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">}</span></div></div><div><br/></div></span>
</div></body></html> 